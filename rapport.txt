Rapport ou2 2015-02-19

Huffmankodning 
Av Jon & Stefan

Inledning:

Huffmanträdet och kodningen till bitar var det centrala i uppgiften, och där vi lagt fokus. Lite kringarbete med main-funktionens upplägg och filhantering har vi gjort, de valen gjordes för enkelhet och funktionalitet. 

Uppdelningen har varit att jon jobbat med bitset och Stefan skapat huffmanträdet.

Definition:


Gjorda val:


Arbetet:

      Hela programmet följer ett antal steg:
	1. Kolla att programmet startats med korrekta växlar och filer.
	2. Oavsett encode eller decode:
	2.1 Gör array av alla tecken i UTF-8
	2.2 Gör frekvensanalys på frekvensfilen 
	2.3 Använd Frekvensanalysen för att bygga upp ett huffmanträd
	3. om encode:
	3.1 Gör en array av Huffmanträdet med bitsets som representerar tecknets placering i huffmanträdet
	3.2 hämta tecken ur infilen, slå upp i arrayen med tecknet som nyckel, lägg till i en bitarray som ska skrivas till fil.
	4. om decode : 
	4.1. Läs in infilen till ett bitset.
	4.2. Traversera huffmanträdet med bitset och när ett löv nås, skriv ut tecknet till fil.

Systemförklaring:
1.
Programmet ska initieras med en växel, och tre filadresser. Genom att main tar char *argv[] så får vi en sträng av hur programmet startades. Main tar också in int argc, som räknar antalet element som programmet startades med, inklusive programmets namn. Först kollas att antalet påståenden vid starten av programmet är korrekt, alltså 5 st.  Sedan görs en strncomp på element 2 ur dessa, som hamnar på plats 1 i chararrayen. motsvarar den "-encode" exakt kommer programmet endast att koda en fil, motsvarar den "-decode" exakt kommer programmet endast att avkoda en fil. Motsvarar den inget av valen så skrivs en text ut som förklarar hur programmet ska användas och sedan stängs programmet.

Nästa steg är att kolla att de två första filsökvägarna faktiskt innehåller en fil. Adress tre är egal om den innehåller fil eller inte, det kommer endast att skrivas dit.  Om någon av de två sökvägarna är oåtkomliga så skrivs ett felmeddeleande ut och programmet stängs.

3.1
treeToArray gör, som funktionsnamnet antyder, en array av huffmanträdet. Vi letar efter barnlösa noder i trädet, som alltså är löven. Den går från vänster till höger i huffmanträdet, när den hittar ett löv så kopieras bitset-pekaren till arrayen av pekare på det index som unsigned char motsvarar. Annars så skriver funktionen false till bitset om den kan gå vänster eller true för höger till bitset, och åkallar sig själv i positionen till vänster alt. höger. När bitset kopierats till voidpekararrayen tas lövet bort, och då kan lövets förälder ha blivit ett löv, som också tas bort tills vi kommer till en förälder som icke är ett löv. Funktionsanropet fortsätter med ett nytt bitset tills endast roten av huffmanträdet kvarstår. 

3.2
encodeText tar emot en array med voidpekare(till bitsets) och två filnamn. Först använder vi fseek för att läsa infilens storlek, sedan skriver vi ut filstorleken till prompten. Filen öppnas igen, och läses med fgetc tills hela filen är läst.  För varje char som läses slås motsvarande bitset upp i vår voidpekar-array. Den bitsetarrayen kopieras steg för steg till slutet på den bitsetarray som heter 'uẗ́'. Efter att hela filen har lästs så innehåller 'ut' motsvarande bitsetarray för varje läst karaktär. Då skrivs bitsetarrayen för stopptecknet '/4' till 'ut'. Efter detta så tar vi 8 minus resten från bitlängden på 'ut' för att få fram antalet oskrivna bitar i arrayen. Vi fyller dessa oskrivna bitar med 1or, endast som en kosmetisk åtgärd. Det släcker felet med uninitialized values i valgrind, och det kostar nästan inget att göra. Slutsteget är att kopiera chararrayen från bitset 'ut' till en annan chararray som kallas bytearr, och den skrivs till utfilen med fwrite. Sedan skrivs bitlängden på 'ut'/8 till prompten, det är hur många bytes som skrivits till utfilen.  

4.1 
För avkodning så kopieras först den kodade filen till en bitset i bitsetFromFile. Det allokeras minne för filens storlek, och sedan kopieras filen till det minnet. 

4.2
I encodeText så använder vi en räknare som räknar hur många bitar som lästs, sedan används varje läst bit som ett steg i huffmanträdet. När ett löv nåtts så skrivs det till fil, och nästa bit börjar ifrån roten på trädet. Detta upprepas tills det löv som nås är tecken '\4' eller tills alla bitar har lästs. 

Relevanta felmeddelanden:

För att kunna koda en text får inte några EOT-tecken('\4') dyka upp i texten, då det används av oss för att koda av texten senare. För att avkoda en text måste EOT förekomma i sista byten av kodad text, annars har antingen fel kodad textfil skickats, eller fel textfrekvensfil skickats. Om tecknet inte förekommer alls så ges också ett felmeddelande. När dessa fel uppstår kommer programmet att terminera med exit(0).  

textfrekvensfilen och infilen får inte vara tomma, de måste ha innehåll för att kunna göra en meningsfull kodning eller avkodning. Däremot behöver inte utfilen vara tom, eller ickeexisterande. Innehållet raderas automatiskt om den existerar, och om den inte existerar så skapas filen automatiskt. Om filerna är tomma så ges ett felmeddelande och programmet terminerar.

Kodning av bitsets:

Bitset var en nästan komplett lösning på kodningsproblemet ifrån huffman-trädet. Det som saknas är ett sätt att plocka ut bitarna från en kodad fil. En mindre irritation är att när man vill skriva icke-initierade värden till en fil så ges det en varning i valgrind. 

För att plocka ut bitarna ifrån den kodade filen skapade vi funktionen bitsetFromFile. Den läser in storleken på filen, skapar en bitset*, allokerar minne för storleken på den kodade filen, och överför den kodade filen till bitsetarrayen med fread. Sedan skickar vi tillbaka pekaren, och har nu gjort kodade filen till en bitset vi kan läsa med funktionerna som finns i bitset.c . 

För varje karaktär i huffmanträdet så skapar vi en bitset som beskriver vägen till karaktären, och dessa lagras i en array av voidpekare till bitsets. Sättet vi valde för att koda infilen är att skapa en ny bitset, som vi skriver varje karaktärs bitset till. När texten är läst så letar vi upp EOT-tecknet '\4' och skriver in det. Har vi sedan bitar över på den sista byten så fyller vi ut med 1:or, för att släcka varningen i valgrind. För att respektera datatypens integritet så använder vi funktionerna och gör en bytearray av den bitset vi skapat, istället för att använde b->array direkt. 

Storleksproblem + spekulation:

Det kommer att finnas några begränsningar på vad som kan behandlas. Vi väljer att inte programmera för detta eftersom vårt mål är att koda ett par sidor text och sedan kunna avkoda det, och begränsningarna ger oss väldigt goda marginaler. Allt under en gigabyte i storleksbegränsning borde vara görbart.

-decode
i funktionen bitsetFromFile i användningen av fread  är storleksbegränsningen åtminstonde unsigned int * byte, så några gigabyte. Detta kan kringås genom att läsa in bitsets en megabyte i taget.

-encode
 när bitset skapas från infilen så används realloc, vilket lägger till en byte när det behövs för att skriva in en extra byte. Denna allokering görs 1024 ggr per kilobyte som skrivs, och kommer att flytta bitset-arrayen när nästa byte inte är ledigt minne. För stora filer är detta onödigt krävande. Det vore enkelt att allokera en megabyte i taget istället.

-encode
När bytearray skrivs till fil så används fwrite, som också är begränsad på unsigned int * byte. 

-encode
Att gå igenom hela tabellen för varje tecken är onödigt vid större avkodningsprojekt, eftersom det finns ett begränsat antal tecken, så kan vi använda en array av pekare till bitsets för att avkoda, för varje tecken som läses in får vi en position i arrayen, som vi sedan tar bitset från och stoppar in i bitset som ska skrivas ut. 

Sedan finns begränsningen när fel frekvensanalysfil skickas med en fil som ska avkodas. Eftersom vi är "lövkompletta", alltså vi kommer alltid att hamna i ett löv oavsett vilken väg vi tar, så kommer vi alltid att få ut en radda tecken i den avkodade filen. Det enda sättet att upptäcka en felaktig frekvensfil är om vi aldrig kommer till stopptecknet. Eller om vi kommer till stopptecknet innan bitset är inne på sista byten. 
