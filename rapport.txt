Rapport ou2 2015-02-19

Huffmankodning 
Av Jon & Stefan

Inledning:

Huffmanträdet och kodningen till bitar var det centrala i uppgiften, och där vi lagt fokus. Lite kringarbete med main-funktionens upplägg och filhantering har vi gjort, de valen gjordes för enkelhet och funktionalitet. 

Uppdelningen har varit att jon jobbat med bitset och Stefan skapat huffmanträdet.

Definition:


Gjorda val:


Arbetet:

      Hela programmet följer ett antal steg:
	1. Kolla att programmet startats med korrekta växlar och filer.
	2. Oavsett encode eller decode:
	2.1 Gör array av alla tecken i UTF-8
	2.2 Gör frekvensanalys på frekvensfilen 
	2.3 Använd Frekvensanalysen för att bygga upp ett huffmanträd
	3. om encode:
	3.1 Gör en array av Huffmanträdet med bitsets som representerar tecknets placering i huffmanträdet
	3.2 hämta tecken ur infilen, slå upp i arrayen med tecknet som nyckel, lägg till i en bitarray som ska skrivas till fil.
	4. om decode : 
	4.1. Läs in infilen till ett bitset.
	4.2. Traversera huffmanträdet med bitset och när ett löv nås, skriv ut tecknet till fil.

Systemförklaring:
1.
Programmet ska initieras med en växel, och tre filadresser. Genom att main tar char *argv[] så får vi en sträng av hur programmet startades. Main tar också in int argc, som räknar antalet element som programmet startades med, inklusive programmets namn. Först kollas att antalet påståenden vid starten av programmet är korrekt, alltså 5 st.  Sedan görs en strncomp på element 2 ur dessa, som hamnar på plats 1 i chararrayen. motsvarar den "-encode" exakt kommer programmet endast att koda en fil, motsvarar den "-decode" exakt kommer programmet endast att avkoda en fil. Motsvarar den inget av valen så skrivs en text ut som förklarar hur programmet ska användas och sedan stängs programmet.

Nästa steg är att kolla att de två första filsökvägarna faktiskt innehåller en fil. Adress tre är egal om den innehåller fil eller inte, det kommer endast att skrivas dit.  Om någon av de två sökvägarna är oåtkomliga så skrivs ett felmeddeleande ut och programmet stängs.

3.1
treeToArray gör, som funktionsnamnet antyder, en array av huffmanträdet. Vi letar efter barnlösa noder i trädet, som alltså är löven. Den går från vänster till höger i huffmanträdet, när den hittar ett löv så kopieras bitset-pekaren till arrayen av pekare på det index som unsigned char motsvarar. Annars så skriver funktionen false till bitset om den kan gå vänster eller true för höger till bitset, och åkallar sig själv i positionen till vänster alt. höger. När bitset kopierats till voidpekararrayen tas lövet bort, och då kan lövets förälder ha blivit ett löv, som också tas bort tills vi kommer till en förälder som icke är ett löv. Funktionsanropet fortsätter med ett nytt bitset tills endast roten av huffmanträdet kvarstår. 

3.2
encodeText tar emot en array med voidpekare(till bitsets) och två filnamn. Först använder vi fseek för att läsa infilens storlek, sedan skriver vi ut filstorleken till prompten. Filen öppnas igen, och läses med fgetc tills hela filen är läst.  För varje char som läses slås motsvarande bitset upp i vår voidpekar-array. Den bitsetarrayen kopieras steg för steg till slutet på den bitsetarray som heter 'uẗ́'. Efter att hela filen har lästs så innehåller 'ut' motsvarande bitsetarray för varje läst karaktär. Då skrivs bitsetarrayen för stopptecknet '/4' till 'ut'. Efter detta så tar vi 8 minus resten från bitlängden på 'ut' för att få fram antalet oskrivna bitar i arrayen. Vi fyller dessa oskrivna bitar med 1or, endast som en kosmetisk åtgärd. Det släcker felet med uninitialized values i valgrind, och det kostar nästan inget att göra. Slutsteget är att kopiera chararrayen från bitset 'ut' till en annan chararray som kallas bytearr, och den skrivs till utfilen med fwrite. Sedan skrivs bitlängden på 'ut'/8 till prompten, det är hur många bytes som skrivits till utfilen.  

4.1 
För avkodning så kopieras först den kodade filen till en bitset i bitsetFromFile. Det allokeras minne för filens storlek, och sedan kopieras filen till det minnet. 

4.2
I encodeText så använder vi en räknare som räknar hur många bitar som lästs, sedan används varje läst bit som ett steg i huffmanträdet. När ett löv nåtts så skrivs det till fil, och nästa bit börjar ifrån roten på trädet. Detta upprepas tills det löv som nås är tecken '\4' eller tills alla bitar har lästs. 

Relevanta felmeddelanden:

För att kunna koda en text får inte några EOT-tecken('\4') dyka upp i texten, då det används av oss för att koda av texten senare. För att avkoda en text måste EOT förekomma i sista byten av kodad text, annars har antingen fel kodad textfil skickats, eller fel textfrekvensfil skickats. Om tecknet inte förekommer alls så ges också ett felmeddelande. När dessa fel uppstår kommer programmet att terminera med exit(0).  

textfrekvensfilen och infilen får inte vara tomma, de måste ha innehåll för att kunna göra en meningsfull kodning eller avkodning. Däremot behöver inte utfilen vara tom, eller ickeexisterande. Innehållet raderas automatiskt om den existerar, och om den inte existerar så skapas filen automatiskt. Om filerna är tomma så ges ett felmeddelande och programmet terminerar.

Kodning av bitsets:

Bitset var en nästan komplett lösning på kodningsproblemet ifrån huffman-trädet. Det som saknas är ett sätt att plocka ut bitarna från en kodad fil. En mindre irritation är att när man vill skriva icke-initierade värden till en fil så ges det en varning i valgrind. 

För att plocka ut bitarna ifrån den kodade filen skapade vi funktionen bitsetFromFile. Den läser in storleken på filen, skapar en bitset*, allokerar minne för storleken på den kodade filen, och överför den kodade filen till bitsetarrayen med fread. Sedan skickar vi tillbaka pekaren, och har nu gjort kodade filen till en bitset vi kan läsa med funktionerna som finns i bitset.c . 

För varje karaktär i huffmanträdet så skapar vi en bitset som beskriver vägen till karaktären, och dessa lagras i en array av voidpekare till bitsets. Sättet vi valde för att koda infilen är att skapa en ny bitset, som vi skriver varje karaktärs bitset till. När texten är läst så letar vi upp EOT-tecknet '\4' och skriver in det. Har vi sedan bitar över på den sista byten så fyller vi ut med 1:or, för att släcka varningen i valgrind. För att respektera datatypens integritet så använder vi funktionerna och gör en bytearray av den bitset vi skapat, istället för att använde b->array direkt. 

Val av tabelltyp:

Först implementerade vi tabell med directed list, vilket fungerade bra då datatypen behöver en nyckel(karaktären) och ett värde(bitset) för kodning av en fil. Men eftersom vi har den exakta storleken på tabellen som avgränsas av hur många sätt en byte kan fyllas på, så kan en unsigned char(har endast positiva värden) vara nyckel i en array, och bitsetpekare eller frekvens är den positionens värde. Med en sådan implementation av typen tabell så behöver aldrig några sökningar göras vid kodning av en fil.
